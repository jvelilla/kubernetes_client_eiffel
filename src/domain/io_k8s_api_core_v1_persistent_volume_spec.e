note
 description:"[
		Kubernetes
 		No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
  		The version of the OpenAPI document: unversioned
 	    

  	NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

 		 Do not edit the class manually.
 	]"
	date: "$Date$"
	revision: "$Revision$"
	EIS:"Eiffel openapi generator", "src=https://openapi-generator.tech", "protocol=uri"
class IO_K8S_API_CORE_V1_PERSISTENT_VOLUME_SPEC




feature --Access

    access_modes: detachable LIST [STRING_32]
      -- AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
    aws_elastic_block_store: detachable IO_K8S_API_CORE_V1_AWS_ELASTIC_BLOCK_STORE_VOLUME_SOURCE
      
    azure_disk: detachable IO_K8S_API_CORE_V1_AZURE_DISK_VOLUME_SOURCE
      
    azure_file: detachable IO_K8S_API_CORE_V1_AZURE_FILE_PERSISTENT_VOLUME_SOURCE
      
    capacity: detachable STRING_TABLE [STRING_32]
      -- A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
    cephfs: detachable IO_K8S_API_CORE_V1_CEPH_FS_PERSISTENT_VOLUME_SOURCE
      
    cinder: detachable IO_K8S_API_CORE_V1_CINDER_PERSISTENT_VOLUME_SOURCE
      
    claim_ref: detachable IO_K8S_API_CORE_V1_OBJECT_REFERENCE
      
    csi: detachable IO_K8S_API_CORE_V1_CSI_PERSISTENT_VOLUME_SOURCE
      
    fc: detachable IO_K8S_API_CORE_V1_FC_VOLUME_SOURCE
      
    flex_volume: detachable IO_K8S_API_CORE_V1_FLEX_PERSISTENT_VOLUME_SOURCE
      
    flocker: detachable IO_K8S_API_CORE_V1_FLOCKER_VOLUME_SOURCE
      
    gce_persistent_disk: detachable IO_K8S_API_CORE_V1_GCE_PERSISTENT_DISK_VOLUME_SOURCE
      
    glusterfs: detachable IO_K8S_API_CORE_V1_GLUSTERFS_PERSISTENT_VOLUME_SOURCE
      
    host_path: detachable IO_K8S_API_CORE_V1_HOST_PATH_VOLUME_SOURCE
      
    iscsi: detachable IO_K8S_API_CORE_V1_ISCSI_PERSISTENT_VOLUME_SOURCE
      
    var_local: detachable IO_K8S_API_CORE_V1_LOCAL_VOLUME_SOURCE
      
    mount_options: detachable LIST [STRING_32]
      -- A list of mount options, e.g. [\"ro\", \"soft\"]. Not validated - mount will simply fail if one is invalid. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes/#mount-options
    nfs: detachable IO_K8S_API_CORE_V1_NFS_VOLUME_SOURCE
      
    node_affinity: detachable IO_K8S_API_CORE_V1_VOLUME_NODE_AFFINITY
      
    persistent_volume_reclaim_policy: detachable STRING_32
      -- What happens to a persistent volume when released from its claim. Valid options are Retain (default for manually created PersistentVolumes), Delete (default for dynamically provisioned PersistentVolumes), and Recycle (deprecated). Recycle must be supported by the volume plugin underlying this PersistentVolume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming  Possible enum values:  - `\"Delete\"` means the volume will be deleted from Kubernetes on release from its claim. The volume plugin must support Deletion.  - `\"Recycle\"` means the volume will be recycled back into the pool of unbound persistent volumes on release from its claim. The volume plugin must support Recycling.  - `\"Retain\"` means the volume will be left in its current phase (Released) for manual reclamation by the administrator. The default policy is Retain.
    photon_persistent_disk: detachable IO_K8S_API_CORE_V1_PHOTON_PERSISTENT_DISK_VOLUME_SOURCE
      
    portworx_volume: detachable IO_K8S_API_CORE_V1_PORTWORX_VOLUME_SOURCE
      
    quobyte: detachable IO_K8S_API_CORE_V1_QUOBYTE_VOLUME_SOURCE
      
    rbd: detachable IO_K8S_API_CORE_V1_RBD_PERSISTENT_VOLUME_SOURCE
      
    scale_io: detachable IO_K8S_API_CORE_V1_SCALE_IO_PERSISTENT_VOLUME_SOURCE
      
    storage_class_name: detachable STRING_32
      -- Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.
    storageos: detachable IO_K8S_API_CORE_V1_STORAGE_OS_PERSISTENT_VOLUME_SOURCE
      
    volume_mode: detachable STRING_32
      -- volumeMode defines if a volume is intended to be used with a formatted filesystem or to remain in raw block state. Value of Filesystem is implied when not included in spec.
    vsphere_volume: detachable IO_K8S_API_CORE_V1_VSPHERE_VIRTUAL_DISK_VOLUME_SOURCE
      

feature -- Change Element

    set_access_modes (a_name: like access_modes)
        -- Set 'access_modes' with 'a_name'.
      do
        access_modes := a_name
      ensure
        access_modes_set: access_modes = a_name
      end

    set_aws_elastic_block_store (a_name: like aws_elastic_block_store)
        -- Set 'aws_elastic_block_store' with 'a_name'.
      do
        aws_elastic_block_store := a_name
      ensure
        aws_elastic_block_store_set: aws_elastic_block_store = a_name
      end

    set_azure_disk (a_name: like azure_disk)
        -- Set 'azure_disk' with 'a_name'.
      do
        azure_disk := a_name
      ensure
        azure_disk_set: azure_disk = a_name
      end

    set_azure_file (a_name: like azure_file)
        -- Set 'azure_file' with 'a_name'.
      do
        azure_file := a_name
      ensure
        azure_file_set: azure_file = a_name
      end

    set_capacity (a_name: like capacity)
        -- Set 'capacity' with 'a_name'.
      do
        capacity := a_name
      ensure
        capacity_set: capacity = a_name
      end

    set_cephfs (a_name: like cephfs)
        -- Set 'cephfs' with 'a_name'.
      do
        cephfs := a_name
      ensure
        cephfs_set: cephfs = a_name
      end

    set_cinder (a_name: like cinder)
        -- Set 'cinder' with 'a_name'.
      do
        cinder := a_name
      ensure
        cinder_set: cinder = a_name
      end

    set_claim_ref (a_name: like claim_ref)
        -- Set 'claim_ref' with 'a_name'.
      do
        claim_ref := a_name
      ensure
        claim_ref_set: claim_ref = a_name
      end

    set_csi (a_name: like csi)
        -- Set 'csi' with 'a_name'.
      do
        csi := a_name
      ensure
        csi_set: csi = a_name
      end

    set_fc (a_name: like fc)
        -- Set 'fc' with 'a_name'.
      do
        fc := a_name
      ensure
        fc_set: fc = a_name
      end

    set_flex_volume (a_name: like flex_volume)
        -- Set 'flex_volume' with 'a_name'.
      do
        flex_volume := a_name
      ensure
        flex_volume_set: flex_volume = a_name
      end

    set_flocker (a_name: like flocker)
        -- Set 'flocker' with 'a_name'.
      do
        flocker := a_name
      ensure
        flocker_set: flocker = a_name
      end

    set_gce_persistent_disk (a_name: like gce_persistent_disk)
        -- Set 'gce_persistent_disk' with 'a_name'.
      do
        gce_persistent_disk := a_name
      ensure
        gce_persistent_disk_set: gce_persistent_disk = a_name
      end

    set_glusterfs (a_name: like glusterfs)
        -- Set 'glusterfs' with 'a_name'.
      do
        glusterfs := a_name
      ensure
        glusterfs_set: glusterfs = a_name
      end

    set_host_path (a_name: like host_path)
        -- Set 'host_path' with 'a_name'.
      do
        host_path := a_name
      ensure
        host_path_set: host_path = a_name
      end

    set_iscsi (a_name: like iscsi)
        -- Set 'iscsi' with 'a_name'.
      do
        iscsi := a_name
      ensure
        iscsi_set: iscsi = a_name
      end

    set_var_local (a_name: like var_local)
        -- Set 'var_local' with 'a_name'.
      do
        var_local := a_name
      ensure
        var_local_set: var_local = a_name
      end

    set_mount_options (a_name: like mount_options)
        -- Set 'mount_options' with 'a_name'.
      do
        mount_options := a_name
      ensure
        mount_options_set: mount_options = a_name
      end

    set_nfs (a_name: like nfs)
        -- Set 'nfs' with 'a_name'.
      do
        nfs := a_name
      ensure
        nfs_set: nfs = a_name
      end

    set_node_affinity (a_name: like node_affinity)
        -- Set 'node_affinity' with 'a_name'.
      do
        node_affinity := a_name
      ensure
        node_affinity_set: node_affinity = a_name
      end

    set_persistent_volume_reclaim_policy (a_name: like persistent_volume_reclaim_policy)
        -- Set 'persistent_volume_reclaim_policy' with 'a_name'.
      do
        persistent_volume_reclaim_policy := a_name
      ensure
        persistent_volume_reclaim_policy_set: persistent_volume_reclaim_policy = a_name
      end

    set_photon_persistent_disk (a_name: like photon_persistent_disk)
        -- Set 'photon_persistent_disk' with 'a_name'.
      do
        photon_persistent_disk := a_name
      ensure
        photon_persistent_disk_set: photon_persistent_disk = a_name
      end

    set_portworx_volume (a_name: like portworx_volume)
        -- Set 'portworx_volume' with 'a_name'.
      do
        portworx_volume := a_name
      ensure
        portworx_volume_set: portworx_volume = a_name
      end

    set_quobyte (a_name: like quobyte)
        -- Set 'quobyte' with 'a_name'.
      do
        quobyte := a_name
      ensure
        quobyte_set: quobyte = a_name
      end

    set_rbd (a_name: like rbd)
        -- Set 'rbd' with 'a_name'.
      do
        rbd := a_name
      ensure
        rbd_set: rbd = a_name
      end

    set_scale_io (a_name: like scale_io)
        -- Set 'scale_io' with 'a_name'.
      do
        scale_io := a_name
      ensure
        scale_io_set: scale_io = a_name
      end

    set_storage_class_name (a_name: like storage_class_name)
        -- Set 'storage_class_name' with 'a_name'.
      do
        storage_class_name := a_name
      ensure
        storage_class_name_set: storage_class_name = a_name
      end

    set_storageos (a_name: like storageos)
        -- Set 'storageos' with 'a_name'.
      do
        storageos := a_name
      ensure
        storageos_set: storageos = a_name
      end

    set_volume_mode (a_name: like volume_mode)
        -- Set 'volume_mode' with 'a_name'.
      do
        volume_mode := a_name
      ensure
        volume_mode_set: volume_mode = a_name
      end

    set_vsphere_volume (a_name: like vsphere_volume)
        -- Set 'vsphere_volume' with 'a_name'.
      do
        vsphere_volume := a_name
      ensure
        vsphere_volume_set: vsphere_volume = a_name
      end


 feature -- Status Report

    output: STRING
          -- <Precursor>
      do
        create Result.make_empty
        Result.append("%Nclass IO_K8S_API_CORE_V1_PERSISTENT_VOLUME_SPEC%N")
        if attached access_modes as l_access_modes then
          across l_access_modes as ic loop
            Result.append ("%N access_modes:")
            Result.append (ic.item.out)
            Result.append ("%N")
          end
        end
        if attached aws_elastic_block_store as l_aws_elastic_block_store then
          Result.append ("%Naws_elastic_block_store:")
          Result.append (l_aws_elastic_block_store.out)
          Result.append ("%N")
        end
        if attached azure_disk as l_azure_disk then
          Result.append ("%Nazure_disk:")
          Result.append (l_azure_disk.out)
          Result.append ("%N")
        end
        if attached azure_file as l_azure_file then
          Result.append ("%Nazure_file:")
          Result.append (l_azure_file.out)
          Result.append ("%N")
        end
        if attached capacity as l_capacity then
          Result.append ("%Ncapacity:")
          across l_capacity as ic loop
            Result.append ("%N")
            Result.append ("key:")
            Result.append (ic.key.out)
            Result.append (" - ")
            Result.append ("val:")
            Result.append (ic.item.out)
            Result.append ("%N")
          end
        end
        if attached cephfs as l_cephfs then
          Result.append ("%Ncephfs:")
          Result.append (l_cephfs.out)
          Result.append ("%N")
        end
        if attached cinder as l_cinder then
          Result.append ("%Ncinder:")
          Result.append (l_cinder.out)
          Result.append ("%N")
        end
        if attached claim_ref as l_claim_ref then
          Result.append ("%Nclaim_ref:")
          Result.append (l_claim_ref.out)
          Result.append ("%N")
        end
        if attached csi as l_csi then
          Result.append ("%Ncsi:")
          Result.append (l_csi.out)
          Result.append ("%N")
        end
        if attached fc as l_fc then
          Result.append ("%Nfc:")
          Result.append (l_fc.out)
          Result.append ("%N")
        end
        if attached flex_volume as l_flex_volume then
          Result.append ("%Nflex_volume:")
          Result.append (l_flex_volume.out)
          Result.append ("%N")
        end
        if attached flocker as l_flocker then
          Result.append ("%Nflocker:")
          Result.append (l_flocker.out)
          Result.append ("%N")
        end
        if attached gce_persistent_disk as l_gce_persistent_disk then
          Result.append ("%Ngce_persistent_disk:")
          Result.append (l_gce_persistent_disk.out)
          Result.append ("%N")
        end
        if attached glusterfs as l_glusterfs then
          Result.append ("%Nglusterfs:")
          Result.append (l_glusterfs.out)
          Result.append ("%N")
        end
        if attached host_path as l_host_path then
          Result.append ("%Nhost_path:")
          Result.append (l_host_path.out)
          Result.append ("%N")
        end
        if attached iscsi as l_iscsi then
          Result.append ("%Niscsi:")
          Result.append (l_iscsi.out)
          Result.append ("%N")
        end
        if attached var_local as l_var_local then
          Result.append ("%Nvar_local:")
          Result.append (l_var_local.out)
          Result.append ("%N")
        end
        if attached mount_options as l_mount_options then
          across l_mount_options as ic loop
            Result.append ("%N mount_options:")
            Result.append (ic.item.out)
            Result.append ("%N")
          end
        end
        if attached nfs as l_nfs then
          Result.append ("%Nnfs:")
          Result.append (l_nfs.out)
          Result.append ("%N")
        end
        if attached node_affinity as l_node_affinity then
          Result.append ("%Nnode_affinity:")
          Result.append (l_node_affinity.out)
          Result.append ("%N")
        end
        if attached persistent_volume_reclaim_policy as l_persistent_volume_reclaim_policy then
          Result.append ("%Npersistent_volume_reclaim_policy:")
          Result.append (l_persistent_volume_reclaim_policy.out)
          Result.append ("%N")
        end
        if attached photon_persistent_disk as l_photon_persistent_disk then
          Result.append ("%Nphoton_persistent_disk:")
          Result.append (l_photon_persistent_disk.out)
          Result.append ("%N")
        end
        if attached portworx_volume as l_portworx_volume then
          Result.append ("%Nportworx_volume:")
          Result.append (l_portworx_volume.out)
          Result.append ("%N")
        end
        if attached quobyte as l_quobyte then
          Result.append ("%Nquobyte:")
          Result.append (l_quobyte.out)
          Result.append ("%N")
        end
        if attached rbd as l_rbd then
          Result.append ("%Nrbd:")
          Result.append (l_rbd.out)
          Result.append ("%N")
        end
        if attached scale_io as l_scale_io then
          Result.append ("%Nscale_io:")
          Result.append (l_scale_io.out)
          Result.append ("%N")
        end
        if attached storage_class_name as l_storage_class_name then
          Result.append ("%Nstorage_class_name:")
          Result.append (l_storage_class_name.out)
          Result.append ("%N")
        end
        if attached storageos as l_storageos then
          Result.append ("%Nstorageos:")
          Result.append (l_storageos.out)
          Result.append ("%N")
        end
        if attached volume_mode as l_volume_mode then
          Result.append ("%Nvolume_mode:")
          Result.append (l_volume_mode.out)
          Result.append ("%N")
        end
        if attached vsphere_volume as l_vsphere_volume then
          Result.append ("%Nvsphere_volume:")
          Result.append (l_vsphere_volume.out)
          Result.append ("%N")
        end
      end
end

